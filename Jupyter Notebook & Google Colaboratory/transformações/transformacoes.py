# -*- coding: utf-8 -*-
"""Transformacoes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TR1ZZ2Jcv6VZGdOUWlEWVX8__u91njJB

#Transformações Geométricas 2D e 3D

As funções abaixo são funcões auxiliares com o intuito de ajudar a plotar e visualizar alguns elementos.

São definições que serão usadas mais adiante.
"""

# Commented out IPython magic to ensure Python compatibility.
#Complementary functions and imports 

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  
# %matplotlib inline
import numpy as np

def set_plots(ax=None,figure = None,figsize=(15,8),lim=[-2,2]):
    if figure ==None:
        figure = plt.figure(figsize=(15,8))
    if ax==None:
        ax=[]
        new_axis = True
    else:
        new_axis=False
    for i in range(2):
        if new_axis:
            ax.append(figure.add_subplot(1,2,i+1,projection='3d'))
        ax[i].set_title("reference arrows example")
        ax[i].set_xlim(lim)
        ax[i].set_xlabel("x axis")
        ax[i].set_ylim(lim)
        ax[i].set_ylabel("y axis")
        ax[i].set_zlim(lim)
        ax[i].set_zlabel("z axis")
    return ax

#adding quivers to the plot
def draw_arrows(point,base,axis,length=1.5):
    for i in range(len(axis)):
        axis[i].quiver(point[0],point[1],point[2],base[0][0],base[0][1],base[0][2],color='red',pivot='tail',  length=length)
        axis[i].quiver(point[0],point[1],point[2],base[1][0],base[1][1],base[1][2],color='green',pivot='tail',  length=length)
        axis[i].quiver(point[0],point[1],point[2],base[2][0],base[2][1],base[2][2],color='blue',pivot='tail',  length=length)

    return axis

"""# Criando a base de um referencial tridimensional

Definição dos vetores 3D e1, e2 e e3, além da origem (0,0,0) em coordenadas homogêneas.

OBS: a variável base é uma lista de vetores (`np.array`)
"""

#base vector values
e1 = np.array([1,0,0]) # X
e2 = np.array([0,1,0]) # Y
e3 = np.array([0,0,1]) # Z
base = [e1,e2,e3]
print ('Cartesian base: ',base)
#origin point
origin_point =np.array([0.0,0.0,0.0,1.0])
print ('Origin: ',origin_point)

"""# Translação e Rotação

###Translação 2D
"""

# Displacements
dx = 2
dy = -1

# Translation vector
t_vector = np.array([dx,dy,1.0])

# Translation matrix
T = np.eye(3)
T[:,-1]=t_vector.T
print('Translation Matrix: \n',T)

# Or
T1 = np.array([[1.0,0,dx],[0,1.0,dy],[0,0,1.0]])
print('Translation Matrix: \n',T1)

# pts0 = [[x1,y1],[x2,y2]...[xn,yn]]
pts0 = np.array([[3,1],[4,2],[-2,5],[0,-3]])
print('Points:\n ',pts0)


# Preparing the points to be in homogeneous coordinates

pts0 = pts0.T
pts0 = np.vstack([pts0,np.ones(pts0.shape[1])])
print('Points:\n ',pts0)


# Translating the points

pts1 = np.dot(T,pts0)
print('Translated Points:\n ',pts1)

# Ploting the original points as red '*' 
plt.figure()
ax0 = plt.axes()
ax0.plot(pts0[0,:],pts0[1,:],'*r')
ax0.grid()
ax0.set_aspect('equal')


# Ploting the new points as blue squares 
ax0.plot(pts1[0,:],pts1[1,:],'s',color='#0D04A8')

"""### Translação 3D

Complete o código nos locais indicados com `##############` para fazer a translação de pontos tridimensionais.

"""

# Displacements
dx = 2
dy = -1
dz = 3

############ Complete ##################
# Translation vector 
t_vector = np.array ([dx, dy, dz, 1])
print('t_vector \n', t_vector)
# Create the translation matrix
T = np.eye(4)
print(T)
T[:,-1] = t_vector.T
print('Translation Matrix: \n',T)
###################################


pts0 = np.array([[3,1,-2], [4,2,1], [-2,5,4], [0,-3,-1]])
print('Points:\n ',pts0)

###################  Complete  #################################
# Preparing the points to be in homogeneous coordinates
pts0 = pts0.T
pts0 = np.vstack((pts0,np.ones(pts0.shape[1])))
print('Points:\n ',pts0)
#################################

# Translating the points
pts1 = np.dot(T,pts0)

###############  Complete #######################
# Ploting the original points as red '*' 
plt.figure()
ax0 = plt.axes(projection='3d')
ax0.plot3D(pts0[0,:], pts0[1,:], pts0[2,:], 'r*')
ax0.grid()

# Ploting the new points as blue '*'
ax0.plot3D(pts1[0,:], pts1[1,:], pts1[2,:], '*b')

###################################################

"""### Representando a Translação com eixos 3D"""

# Displacements
dx = 1
dy = 1
dz = 1

# Translation vector - Complete
t_vector = np.array([dx,dy,dz,1.0])

# Translation matrix
T = np.eye(4)
T[:,-1]=t_vector.T
print('Translation Matrix: \n',T)

#original point 
axis = set_plots(lim=[0,5])
axis = draw_arrows(origin_point,base,axis)

#translation as a multiplication using homogeneos coordinates
#changed length only for representation

translated_point = np.dot(T,origin_point)
print('Origin (0,0,0) translate by [1,1,1]:')
print(translated_point)
axis = draw_arrows(translated_point,base,axis,length=1.0)
#set camera view options of a plot
axis[0].view_init(elev=10,azim=15)
axis[0].dist=10

# Incrementing the translation

T[:,-1]=np.array([2,2,2,1]).T
#changed length only for representation
translated_point_mult = np.dot(T,origin_point)
print('Origin (0,0,0) translated by [2,2,2]:')
print(translated_point_mult)
axis = draw_arrows(translated_point_mult,base,axis,length=0.5)


#set camera view options of a plot
axis[1].view_init(elev=90,azim=0)
axis[1].dist=7

plt.show()

"""### Rotação 2D"""

# Angle of Rotation
ang = 45
ang_rad = (45/180)*np.pi

# Rotation matrix
R = np.eye(3)
R[0,0] = np.cos(ang_rad)
R[0,1] = -np.sin(ang_rad)
R[1,0] = np.sin(ang_rad)
R[1,1] = np.cos(ang_rad)

print('Rotation Matrix: \n',R)


pts0 = np.array([[3,1],[5,1],[5,3],[3,3],[3,1]])
print('Points:\n ',pts0)


# Preparing the points to be in homogeneous coordinates

pts0 = pts0.T
pts0 = np.vstack([pts0,np.ones(pts0.shape[1])])
print('Points:\n ',pts0)

# Rotating the points

pts1 = np.dot(R,pts0)

# Ploting the original points as a red line 
plt.figure()
ax0 = plt.axes()
ax0.plot(pts0[0,:],pts0[1,:],color='#A50088')
ax0.grid()
ax0.set_aspect('equal')


# Ploting the new points as a blue line 
ax0.plot(pts1[0,:],pts1[1,:],'--b')

"""### Rotação 3D

Complete o código nos trechos indicados com `###############` para fazer a rotação 3D no eixo Z.
"""

# Angle of Rotation
ang = 45
ang_rad = (45/180)*np.pi


##########  Complete ########
# Rotation matrix
R = np.eye(4)
R[0,0] = np.cos(ang_rad)
R[0,1] = -np.sin(ang_rad)
'''R[0,2] = 0'''
R[1,0] = np.sin(ang_rad)
R[1,1] = np.cos(ang_rad)
'''R[1,2] = 0
R[2,0] = 0
R[2,1] = 0
R[2,2] = 1'''
print('Rotation Matrix: \n',R)
###########################

pts0 = np.array([[3,1,4],[5,1,4],[5,3,4],[3,3,4],[3,1,4]])
print('Points:\n ',pts0)

########## Complete ######################
# Preparing the points to be in homogeneous coordinates

pts0 = pts0.T
pts0 = np.vstack((pts0, np.ones(pts0.shape[1])))
print('Points:\n ',pts0)

######## Complete  #########
# Rotating the points
pts1 = np.dot(R, pts0)
#########################


################  Complete  #############################
# Ploting the original points as a red line 
plt.figure()
ax0 = plt.axes(projection='3d')
ax0.plot3D(pts0[0,:], pts0[1,:], pts0[2,:], color='r')
ax0.grid()


# Ploting the new points as a blue line 
ax0.plot3D(pts1[0,:], pts1[1,:], pts1[2,:], color='b')
#########################################

"""### Definindo funções para criar rotações 3D

Vamos usar tais funções para rotacionar os eixos de um referencial.
Além de rotacionar, o referencial também será transladado.

Há uma função de rotação em torno do eixo Z como exemplo. Crie as funções de rotação para os outros eixos X e Y. Crie também a função para translação. Os locais onde você deverá adicionar suas funções ou alterar o código atual estão indicados com '###################'

Para facilitar as matrizes de rotação em torno de cada eixo são:

>

$R_x(\theta) = \begin{bmatrix} 
1 & 0 & 0 & 0\\
0 & cos(\theta) & -sen(\theta) & 0 \\
0 & sen(\theta) & cos(\theta) & 0 \\
0 & 0 & 0 & 1 
\end{bmatrix}$

$R_y(\theta) = \begin{bmatrix} 
cos(\theta) & 0 & sen(\theta) & 0 \\
0 & 1 & 0 & 0 \\
-sen(\theta) & 0 & cos(\theta) & 0 \\
0 & 0 & 0 & 1 
\end{bmatrix}$

$R_z(\theta) = \begin{bmatrix} 
cos(\theta) & -sen(\theta) & 0 & 0 \\
sen(\theta) & cos(\theta) & 0  & 0\\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 
\end{bmatrix}$


"""

from math import pi,cos,sin

# Function for building the Rotation Matrix around the axes

def x_rotation(angle):
    rotation_matrix=np.array([[1,0,0,0],[0, cos(angle),-sin(angle),0],[0, sin(angle),cos(angle),0],[0,0,0,1]])
    return rotation_matrix

def y_rotation(angle):
    rotation_matrix=np.array([[cos(angle),0,sin(angle),0],[0,1,0,0],[-sin(angle),0,cos(angle),0],[0,0,0,1]])
    return rotation_matrix

def z_rotation(angle):
    rotation_matrix=np.array([[cos(angle),-sin(angle),0,0],[sin(angle),cos(angle),0,0],[0,0,1,0],[0,0,0,1]])
    return rotation_matrix

def translade(dx, dy, dz):
    translation = np.array([dx,dy,dz,1])
    T_matrix = np.eye(4)
    T_matrix[:,-1]=translation.T
    return T_matrix

#################################
    
rotation_angle = pi/2 #in radians
Rx = x_rotation(rotation_angle)
print('Rx:\n', Rx,'\n')
Ry = y_rotation(rotation_angle)
print('Ry:\n', Ry,'\n')
Rz = z_rotation(rotation_angle)
print('Rz:\n', Rz,'\n')
T = translade(2,1,3)
print('T:\n', T,'\n')

#original point 
axis = set_plots(lim=[-5,5])
axis = draw_arrows(origin_point,base,axis)



print('Translation matrix:')
print(T,'\n')

R = Ry

rotated_point_mult = np.dot(R,origin_point)

print('Rotating the origin does not change anything',rotated_point_mult)
print(rotated_point_mult.shape)

# Rotating the base attached to the point

e1_rotated = np.dot(R,np.hstack([np.array(e1), [0]]))
e2_rotated = np.dot(R,np.hstack([np.array(e2), [0]]))
e3_rotated = np.dot(R,np.hstack([np.array(e3), [0]]))
base_rotated = [e1_rotated[0:3],e2_rotated[0:3],e3_rotated[0:3]]

print('Rotated base:')
print(base_rotated)

#Translate the point

translated_point_mult = np.dot(T,rotated_point_mult.T)

 
#changed length only for representation
axis = draw_arrows(translated_point_mult,base_rotated,axis,length=1.0)


#set camera view options of a plot
axis[1].view_init(elev=90,azim=0)
axis[1].dist=7

plt.show()

"""### Desenhando um Objeto """

#Creating a house

house = np.array([[0,         0,         0],
         [0,  -10.0000,         0],
         [0, -10.0000,   12.0000],
         [0,  -10.4000,   11.5000],
         [0,   -5.0000,   16.0000],
         [0,         0,   12.0000],
         [0,    0.5000,   11.4000],
         [0,         0,   12.0000],
         [0,         0,         0],
  [-12.0000,         0,         0],
  [-12.0000,   -5.0000,         0],
  [-12.0000,  -10.0000,         0],
         [0,  -10.0000,         0],
         [0,  -10.0000,   12.0000],
[-12.0000,  -10.0000,   12.0000],
  [-12.0000,         0,   12.0000],
         [0,         0,   12.0000],
         [0,  -10.0000,   12.0000],
         [0,  -10.5000,   11.4000],
  [-12.0000,  -10.5000,   11.4000],
  [-12.0000,  -10.0000,   12.0000],
  [-12.0000,   -5.0000,   16.0000],
         [0,   -5.0000,   16.0000],
         [0,    0.5000,   11.4000],
  [-12.0000,    0.5000,   11.4000],
  [-12.0000,         0,   12.0000],
  [-12.0000,   -5.0000,   16.0000],
  [-12.0000,  -10.0000,   12.0000],
  [-12.0000,  -10.0000,         0],
  [-12.0000,   -5.0000,         0],
  [-12.0000,         0,         0],
  [-12.0000,         0,   12.0000],
  [-12.0000,         0,         0]])

house = np.transpose(house)

#Plotting the house

figure = plt.figure(figsize=(10,10))
ax0 = plt.axes(projection='3d')
ax0.plot3D(house[0,:], house[1,:], house[2,:], 'red')

#Representing the object in homogeneous coordinates
#create row of ones
num_columns = np.size(house,1)
ones_line = np.ones(num_columns)


#add to the house matrix to represent the house in homogeneous coordinates
house = np.vstack([house, ones_line])

"""### Movendo o objeto"""

from math import pi,cos,sin

# Function for building the Rotation Matrix around the Z-axes
def z_rotation(angle):
    rotation_matrix=np.array([[cos(angle),-sin(angle),0,0],[sin(angle),cos(angle),0,0],[0,0,1,0],[0,0,0,1]])
    return rotation_matrix

# Useful function to create an 'equal' aspect ratio for 3D plots
def axisEqual3D(ax):
    extents = np.array([getattr(ax, 'get_{}lim'.format(dim))() for dim in 'xyz'])
    sz = extents[:,1] - extents[:,0]
    centers = np.mean(extents, axis=1)
    maxsize = max(abs(sz))
    r = maxsize/2
    for ctr, dim in zip(centers, 'xyz'):
        getattr(ax, 'set_{}lim'.format(dim))(ctr - r, ctr + r)


#Define the translation matrix
translation = np.array([10.0,10.0,10.0,0.0])

T = np.eye(4)
T[:,-1]=translation.T
T[3,3]=1
#print('Translation Matrix: \n',T)

#Translate the house
new_house = np.dot(T,house)

figure = plt.figure(figsize=(30,15))
ax0 = figure.add_subplot(1,2,1, projection='3d')
#plot original house in red
ax0.plot3D(house[0,:], house[1,:], house[2,:], 'red')
#plot new house in blue
ax0.plot3D(new_house[0,:],new_house[1,:],new_house[2,:], 'blue')
axisEqual3D(ax0)


#Rotate the house along the z-axis
rotation_angle = pi/4 #in radians
Rz = z_rotation(rotation_angle)
new_house2 = np.dot(Rz,new_house)
ax1 = figure.add_subplot(1,2,2, projection='3d')
#plot original house in red
ax1.plot3D(house[0,:], house[1,:], house[2,:], 'red')
ax1.plot3D(new_house2[0,:],new_house2[1,:],new_house2[2,:], color='#0D63A0')
axisEqual3D(ax1)